#!/usr/bin/env python
from ast import IsNot
import rospy
import os
from sensor_msgs.msg import Joy
from mmpug_msgs.msg import DirectionalInput, GoalInput, MMPUGModes
from geometry_msgs.msg import PointStamped, TwistStamped, PoseArray, PoseStamped
from nav_msgs.msg import Odometry
from std_msgs.msg import Bool, String, Float32, UInt8, Header
from mavros_msgs.msg import State
from mavros_msgs.srv import CommandBool
from system_stats.msg import Float32Stamped
from std_srvs.srv import SetBool
from spot_msgs.srv import SetLocomotion
import time
import math
import string
import ctypes

class Modes():
    INIT_MODE = MMPUGModes.INIT_MODE
    JOYSTICK_MODE = MMPUGModes.JOYSTICK_MODE
    WAYPOINT_MODE = MMPUGModes.WAYPOINT_MODE
    EXPLORATION_MODE = MMPUGModes.EXPLORATION_MODE
    MANUAL_MODE = MMPUGModes.MANUAL_MODE
    ESTOPPED = MMPUGModes.ESTOPPED

    @staticmethod
    def isValid(mode):
        if mode < 0 or mode > 5:
            return False
        return True

    @staticmethod
    def toString(mode):
        strings = {
            Modes.INIT_MODE: "Init",
            Modes.JOYSTICK_MODE: "Joystick Mode",
            Modes.WAYPOINT_MODE: "Waypoint Mode",
            Modes.EXPLORATION_MODE: "Exploration Mode",
            Modes.MANUAL_MODE: "Manual Mode",
            Modes.ESTOPPED: "Estopped"
        }
        return strings[mode]

class MessageStacker():
    def __init__(self):
        self.messages = []

    def update(self):
        i = 0
        while i < len(self.messages):
            if time.time() >= self.messages[i][0]:
                self.messages.pop(i)
                continue
            i += 1
    
    def addMessage(self, message_contents, life = 5.0):
        death_time = time.time() + life
        for i in range(len(self.messages)):
            if self.messages[i][1] == message_contents:
                self.messages[i] = (death_time, message_contents)
                return
        self.messages.append((death_time, message_contents))

    def getMessages(self, asc_len = True):
        self.update()
        if len(self.messages) > 0:
            return sorted([m[1] for m in self.messages], reverse=not asc_len, key=len)
        return ""
    
class ExecutiveNode():
    def __init__(self):
        # State Management
        self.mode = Modes.INIT_MODE
        self.state_change_timeout = 0.5
        self.state_change_time = 0

        # Exploration
        self.exploration_enabled = False
        self.exploration_waypoint_time = 0.
        self.exploration_waypoint_timeout = 1.0
        self.exploration_waypoint = None
        self.exploration_complete = False
        self.exploration_exit_time = 0.0

        # Feedback
        self.odom = None
        self.first_odom_time = 0.0
        self.last_odom_time = 0.0
        self.odom_init_timeout = 10.
        self.odom_failure_timeout = 0.5

        # Input
        self.joystick_input = None
        self.joystick_input_time = 0.
        self.waypoints = None
        self.waypoints_idx = 0
        self.waypoint_exit_time = None

        # Arming
        self.mavros_is_armed = None
        self.valid_arm_disarm_data = False
        self.arm_switch_timeout = 0.5
        self.arm_switch_time = 0
        self.mavros_arm_state_time = 0.
        self.mavros_arm_data_timeout = 1.5
        self.arm_request = False
        self.disarm_request = False

        self.messages = MessageStacker()

        # Convoy
        self.is_leader = False
        self.in_convoy = False
        self.leading_dist = 0.0
        self.following_odom = None
        self.conv_speed_ratio = 1.0

        ### Key: Mode
        ### Value: (state_function, mode_entry_function (can be None), mode_exit_function (can be None))
        self.mode_handlers = {
            Modes.INIT_MODE: (self.init_mode, None, None),
            Modes.JOYSTICK_MODE: (self.joystick_mode, None, None),
            Modes.WAYPOINT_MODE: (self.waypoint_mode, self.waypoint_enter_function, self.waypoint_exit_function),
            Modes.EXPLORATION_MODE: (self.exploration_mode, self.exploration_enter_function, self.exploration_exit_function),
            Modes.MANUAL_MODE: (self.manual_mode, None, None)
        }

        self.joystick_speed = rospy.get_param("~joystick_speed", 2.)
        self.waypoint_speed = rospy.get_param("~waypoint_speed", 2.)
        self.exploration_speed = rospy.get_param("~exploration_speed", 2.)
        self.manual_speed = rospy.get_param("~manual_speed", 4.)
        self.turning_radius_degrees = rospy.get_param("~turning_radius_degrees", 45)
        self.joystick_noise_deadband = rospy.get_param("~joystick_noise_deadband", 0.02)
        self.joystick_noise_deadband_latjs = self.joystick_noise_deadband * 2
        self.state_change_timeout = rospy.get_param("~state_change_timeout", 0.5)
        self.joystick_timeout_sec = rospy.get_param("~joystick_timeout_sec", 0.5)
        self.enable_mavros_timeout = rospy.get_param("~enable_mavros_timeout", True)
        self.waypoint_death_on_exit = rospy.get_param("~waypoint_death_on_exit", False)
        self.waypoint_mode_timeout = rospy.get_param("~waypoint_mode_timeout", 10.0)
        self.exploration_mode_timeout = rospy.get_param("~exploration_mode_timeout", 10.0)
        self.system_type = rospy.get_param("~system_type", 'rc')
        self.system_id = rospy.get_param("~system_id", 'rc1')

        # Control Feedback
        self.state_string_pub = rospy.Publisher("executive/mode/string", String, queue_size=1)
        self.state_int_pub = rospy.Publisher("executive/mode/int", UInt8, queue_size=1)
        self.arm_state_pub = rospy.Publisher("executive/armed", Bool, queue_size=1)
        self.messages_pub = rospy.Publisher("executive/messages", String, queue_size=1)
        self.active_waypoint_pub = rospy.Publisher("executive/active_waypoints", PoseArray, queue_size=1)
        self.cpu_float_pub = rospy.Publisher("executive/cpu_usage", Float32, queue_size=1)
        self.disk_float_pub = rospy.Publisher("executive/disk_usage", Float32, queue_size=1)
        # self.lock_status_pub = rospy.Publisher("executive/locked", String, queue_size=1)

        # Control Input (from control interface assumably)
        self.joy_sub = rospy.Subscriber("executive/command/joy", Joy, self.joyCB)
        self.wp_sub = rospy.Subscriber("executive/command/waypoints", PoseArray, self.waypointsCB)
        self.state_sub = rospy.Subscriber("executive/command/mode", UInt8, self.stateRequestCB)
        self.state_sub = rospy.Subscriber("executive/command/arm", Bool, self.armRequestCB)
        self.wp_sub = rospy.Subscriber("executive/command/enable_exploration", Bool, self.explorationEnableCB)
        # self.lock_status_sub = rospy.Subscriber("executive/command/lock_status", String, self.lock_statusCB)

        # System State Monitoring / Feedback
        self.odometry_sub = rospy.Subscriber("integrated_to_global", Odometry, self.odometryCB)
        self.mavros_state_sub = rospy.Subscriber("low_level_control/arm_status", Bool, self.hardwareArmCB)
        self.arm_disarm_service = rospy.ServiceProxy("low_level_control/arming", SetBool)
        self.cpu_stats_sub = rospy.Subscriber("system/cpu/usage", Float32Stamped, self.cpuStatsCB)
        self.disk_usage_sub = rospy.Subscriber("system/disk/usage", Float32Stamped, self.diskUsageCB)

        # Exploration (The only mode not directly driven by user input)
        self.exp_wp_sub = rospy.Subscriber("exploration/waypoint", PoseStamped, self.explorationWaypointCB)
        self.exp_wp_sub = rospy.Subscriber("exploration/complete", Bool, self.explorationCompleteCB)
        self.exploration_trigger_pub = rospy.Publisher("exploration/trigger", Bool, queue_size=10)

        # Control Output
        self.direction_input_pub = rospy.Publisher("planner/directional_input", DirectionalInput, queue_size=1)
        self.goal_input_pub = rospy.Publisher("planner/goal_input", GoalInput, queue_size=1)
        self.twist_output_pub = rospy.Publisher("low_level_control/manual_override", TwistStamped, queue_size=1)

        # Convoy
        self.has_leading_sub = rospy.Subscriber("convoy_interface/is_leader", Bool, self.isLeaderCB)
        self.in_convoy_sub = rospy.Subscriber("convoy_interface/in_convoy", Bool, self.inConvoyCB)
        self.following_odom_sub = rospy.Subscriber("convoy_interface/following_odom", Odometry, self.followingOdomCB)
        self.following_odom_sub = rospy.Subscriber("convoy_interface/speed_ratio", Float32, self.speedRatioCB)

        # Spot Locomotion Service
        self.spot_locomotion_service = rospy.ServiceProxy('spot/locomotion_mode', SetLocomotion)
        self.spot_stair_service = rospy.ServiceProxy('spot/stair_mode', SetBool)
    ###########################################################################
    # Some Utility Functions
    ###########################################################################
    def transition(self, mode):
        rospy.loginfo("Transitioning from [%s] to [%s]"%(
            Modes.toString(self.mode),
            Modes.toString(mode)
        ))
        if self.mode != mode:
            # If the current mode has an exit function, call it
            if self.mode_handlers[self.mode][2] is not None:
                self.mode_handlers[self.mode][2]()
            # if the new mode has an entry function, call it
            if self.mode_handlers[mode][1] is not None:
                self.mode_handlers[mode][1]()
        self.mode = mode

    def getDist(self, odom, waypoint):
        odom_x = odom.pose.pose.position.x
        odom_y = odom.pose.pose.position.y
        goal_x = waypoint.position.x
        goal_y = waypoint.position.y

        return math.sqrt((odom_x - goal_x)**2 + (odom_y - goal_y)**2)
    
    def getDistConvoy(self, odom1, odom2):
        odom_x = odom1.pose.pose.position.x
        odom_y = odom1.pose.pose.position.y
        goal_x = odom2.pose.pose.position.x
        goal_y = odom2.pose.pose.position.y

        return math.sqrt((odom_x - goal_x)**2 + (odom_y - goal_y)**2)

    def getSpeedRatio(self, odom, waypoint, slow_deadband, kill_deadband):
        goal_dist = self.getDist(odom, waypoint)

        if goal_dist < kill_deadband:
            return 0.
        elif goal_dist - kill_deadband < slow_deadband:
            return (goal_dist - kill_deadband) / slow_deadband
        return 1.0

    # Generate different commands (returnably by state functions)
    def direction_cmd(self, speed, direction, check_obstacle = True):
        ctl_msg = DirectionalInput()
        ctl_msg.target_velocity = speed
        ctl_msg.direction = direction
        ctl_msg.check_obstacle = True
        return ("DIR", ctl_msg)

    def waypoint_cmd(self, goal_x, goal_y, speed, check_obstacle = True):
        ctl_msg = GoalInput()
        ctl_msg.goal_x = goal_x
        ctl_msg.goal_y = goal_y
        ctl_msg.target_velocity = speed
        ctl_msg.check_obstacle = True
        return ("WPT", ctl_msg)

    def twist_cmd(self, linear, angular, lateral):
        ctl_msg = TwistStamped()
        ctl_msg.twist.linear.x = linear
        ctl_msg.twist.linear.y = lateral
        ctl_msg.twist.angular.z = angular
        return ("TWST", ctl_msg)

    def gp_waypoint_cmd(self, goal_x, goal_y, speed, check_obstacle = True):
        ctl_msg = GoalInput()
        ctl_msg.goal_x = goal_x
        ctl_msg.goal_y = goal_y
        ctl_msg.target_velocity = speed
        ctl_msg.check_obstacle = True
        return ("GP_WPT", ctl_msg)

    def publish_active_waypoints(self, header, pose_array):
        active_waypoints_msg = PoseArray()
        active_waypoints_msg.header = header
        active_waypoints_msg.poses = pose_array
        self.active_waypoint_pub.publish(active_waypoints_msg)

    ###########################################################################
    # State functions! (must return one of the above cmd's
    # or a tuple of the form (cmd_type, cmd_msg))
    ###########################################################################
    def init_mode(self):
        now = time.time()
        joystick_init = self.joystick_input is not None
        odom_recieved = self.odom is not None
        odom_init = now - self.first_odom_time > self.odom_init_timeout
        if joystick_init and odom_recieved and odom_init:
            self.transition(Modes.MANUAL_MODE)
        else:
            if not joystick_init:
                self.messages.addMessage("[ERR][INIT] No joystick input recieved yet", 0.1)
            if not odom_recieved:
                self.messages.addMessage("[ERR][INIT] No odometry recieved yet", 0.1)
                rospy.logwarn_throttle(2, "No odometry recieved yet.")
            elif not odom_init:
                time_to_init = self.odom_init_timeout - (now - self.first_odom_time)
                self.messages.addMessage("[WARN][INIT] Waiting %3ds for estimation to initialize"%int(time_to_init), 0.1)
                rospy.logwarn_throttle(2, "Waiting %3.2fs for estimation to initialize."%time_to_init)
        return self.twist_cmd(0, 0, 0)

    def joystick_mode(self):
        speed = 0.0
        direction = 0.0
        if self.valid_joystick:
            if self.system_type == 'spot': #Pass twist for spot and not direction.
                norm = math.sqrt(self.joystick_x**2 + self.joystick_lateral**2) + 1e-6
                speed = self.joystick_x * self.joystick_speed / norm
                if math.fabs(self.joystick_x) < self.joystick_noise_deadband:
                    speed = 0
                lateral_speed = self.joystick_lateral * self.joystick_speed / norm
                if math.fabs(self.joystick_lateral) < self.joystick_noise_deadband_latjs:
                    lateral_speed = 0
                direction = self.joystick_y * self.joystick_speed  #direction is rotational speed in spot
                if math.fabs(direction) > 1:
                    if direction > 1:
                        direction = 1
                    else:
                        direction = -1
                if math.fabs(self.joystick_y) < self.joystick_noise_deadband:
                    direction = 0  
                return self.twist_cmd(speed, direction, lateral_speed/2)

            else:
                speed = math.sqrt(self.joystick_x**2 + self.joystick_x**2) * self.joystick_speed
                if speed > self.joystick_speed:
                    speed = self.joystick_speed
            
                direction = math.atan2(self.joystick_y, self.joystick_x)
                if math.fabs(self.joystick_x) < self.joystick_noise_deadband:
                    speed = 0
                if math.fabs(self.joystick_y) < self.joystick_noise_deadband:
                    direction = 0
                    # Even if y is 0, if x is negative we need to point in reverse
                    if self.joystick_x < self.joystick_noise_deadband:
                        direction = math.pi
                
                # Convoy leader speed variation
                if self.is_leader == True and direction != math.pi:
                    speed *= self.conv_speed_ratio
                    self.messages.addMessage("[INFO][CNV] In Convoy", 1.0)

                return self.direction_cmd(speed, direction)
        return self.direction_cmd(0, 0)

    def waypoint_mode(self):
        # If not in convoy or is convoy leader
        if not self.in_convoy or self.is_leader:
            fail = False
            if self.waypoints == None or len(self.waypoints.poses) <= 0:
                self.waypoints_idx = 0
                self.messages.addMessage("[WARN][WPT] No waypoint to execute.", 0.1)
                rospy.logwarn_throttle(2, "No waypoint to execute.")
                fail = True
            
            while not fail:
                current_waypoint = self.waypoints.poses[0]

                decel_dist = 4.0
                waypoint_next_dist = 4.0
                achieved_dist = 0.8
                goal_dist = 0.0
                speed_ratio = 0.0

                goal_dist = self.getDist(self.odom, current_waypoint)
                speed_ratio = self.getSpeedRatio(self.odom, current_waypoint, decel_dist, achieved_dist)

                # Convoy leader speed variation
                if self.is_leader == True:
                    speed_ratio *= self.conv_speed_ratio
                    self.messages.addMessage("[INFO][CNV] In Convoy", 1.0)

                if len(self.waypoints.poses) > 1 and goal_dist < waypoint_next_dist:
                    self.messages.addMessage("[INFO][WPT] Waypoint %d achieved"%self.waypoints_idx, 1.0)
                    rospy.loginfo("Waypoint %d achieved!"%self.waypoints_idx)
                    self.waypoints_idx += 1
                    self.waypoints.poses.pop(0)
                    continue

                elif goal_dist < achieved_dist:
                    self.waypoints = None
                    self.messages.addMessage("[INFO][WPT] Waypoint %d achieved"%self.waypoints_idx, 1.0)
                    rospy.loginfo("Waypoint %d achieved!"%self.waypoints_idx)
                    return self.direction_cmd(0., 0.)

                goal_x = current_waypoint.position.x
                goal_y = current_waypoint.position.y
                return self.waypoint_cmd(goal_x, goal_y, self.waypoint_speed * speed_ratio)

            if fail:
                return self.direction_cmd(0,0)

        # If following another robot in convoy
        else:
            self.messages.addMessage("[INFO][CNV] In Convoy", 1.0)

            goal_x = self.following_odom.pose.pose.position.x
            goal_y = self.following_odom.pose.pose.position.y
            return self.waypoint_cmd(goal_x, goal_y, self.waypoint_speed * self.conv_speed_ratio)


    def waypoint_enter_function(self):
        if self.waypoints is not None and self.waypoint_exit_time is not None:
            if math.fabs(time.time() - self.waypoint_exit_time) > self.waypoint_mode_timeout:
                self.waypoint_exit_time = None
                rospy.logwarn("Cleared waypoints due to waypoint mode timeout.")
                self.waypoints = None

    def waypoint_exit_function(self):
        self.waypoint_exit_time = time.time()
        if self.waypoint_death_on_exit:
            rospy.logwarn("Cleared waypoints due to waypoint mode exit.")
            self.waypoints = None

    def exploration_mode(self):
        exploration_enabled = self.exploration_enabled
        fail = False
        if not exploration_enabled:
            self.messages.addMessage("[WARN][EXP] Exploration is not enabled", 0.1)
            rospy.logwarn_throttle(2, "Exploration enabled")
            fail = True
        
        if self.exploration_waypoint is None and self.exploration_enabled:
            self.messages.addMessage("[WARN][EXP] Exploration is enabled, but no waypoint is received yet.", 0.1)
            rospy.logwarn_throttle(2, "Exploration enabled, but no waypoint yet")
            fail = True

        exploration_trigger_msg = Bool()
        exploration_trigger_msg.data = exploration_enabled
        self.exploration_trigger_pub.publish(exploration_trigger_msg)
        
        if fail:
            return self.direction_cmd(0,0)

        decel_dist = 4.0
        achieved_dist = 0.3
        speed_ratio = self.getSpeedRatio(self.odom, self.exploration_waypoint.pose, decel_dist, achieved_dist)

        goal_x = self.exploration_waypoint.pose.position.x
        goal_y = self.exploration_waypoint.pose.position.y
        return self.waypoint_cmd(goal_x, goal_y, self.exploration_speed * speed_ratio)

    def exploration_enter_function(self):
        self.exploration_waypoint = None
        if self.exploration_enabled and math.fabs(time.time() - self.exploration_exit_time) > self.exploration_mode_timeout:
            self.exploration_enabled = False
            self.exploration_waypoint = None

    def exploration_exit_function(self):
        exploration_trigger_msg = Bool()
        exploration_trigger_msg.data = False
        self.exploration_trigger_pub.publish(exploration_trigger_msg)
        self.exploration_exit_time = time.time()

    def manual_mode(self):
        if not self.valid_joystick:
            return self.direction_cmd(0., 0.)

        if(self.system_type == 'spot'):
            norm = math.sqrt(self.joystick_x**2 + self.joystick_lateral**2) + 1e-6
            speed = self.joystick_x * self.manual_speed / norm
            if math.fabs(self.joystick_x) < self.joystick_noise_deadband:
                speed = 0
            lateral_speed = self.joystick_lateral * self.manual_speed / norm
            if math.fabs(self.joystick_lateral) < self.joystick_noise_deadband:
                lateral_speed = 0
            direction = self.joystick_y * self.manual_speed #direction is rotational speed in spot
            if math.fabs(direction) > 1:
                    if direction > 1:
                        direction = 1
                    else:
                        direction = -1
            if math.fabs(self.joystick_y) < self.joystick_noise_deadband:
                direction = 0    
        else:
            speed = self.joystick_x * self.manual_speed
            if math.fabs(self.joystick_x) < self.joystick_noise_deadband:
                speed = 0
            direction = self.joystick_y * self.turning_radius_degrees * math.pi / 180.
            if math.fabs(self.joystick_y) < self.joystick_noise_deadband:
                direction = 0
            lateral_speed = 0
            
        

        return self.twist_cmd(speed, direction, lateral_speed/2)

    ###########################################################################
    # Core Logic / Execution Loop
    ###########################################################################
    def requestArm(self, arm_request, disarm_request):
        if self.mavros_is_armed is None or not self.valid_arm_disarm_data:
            return

        if not arm_request and not disarm_request:
            return

        arm = False
        if arm_request:
            arm = True

        if arm and self.mavros_is_armed:
            return
        if not arm and not self.mavros_is_armed:
            return

        if math.fabs(time.time() - self.arm_switch_time) < self.arm_switch_timeout:
            return

        try:
            rospy.loginfo("Attempting to %s ardupilot."%("arm" if arm else "disarm"))
            resp1 = self.arm_disarm_service(arm)
        except rospy.ServiceException as exc:
            self.messages.addMessage("[ERR] Failed to %s"%("arm" if arm else "disarm"), 3)
            rospy.logerr("Service did not process request: " + str(exc))

    def run(self):
        r = rospy.Rate(50)
        rospy.loginfo("Loading into [%s]"%(Modes.toString(self.mode)))
        joystick_timed_out = True
        check_obstacle = True

        while not rospy.is_shutdown():
            now = time.time()
            rospy.loginfo_throttle(5, "Currently in [%s]"%(Modes.toString(self.mode)))

            # Check joystick validity
            self.valid_joystick = True
            if self.joystick_input == None or math.fabs(now - self.joystick_input_time) > self.joystick_timeout_sec:
                self.messages.addMessage("[WARN] No joystick data being recieved.", 0.1)
                rospy.logerr_throttle(5, "[WARN] No joystick data being recieved")
                self.valid_joystick = False
            else:
                self.valid_joystick = True

            self.joystick_x = None
            self.joystick_y = None
            self.joystick_lateral = None
            if self.valid_joystick:
                self.joystick_x = self.joystick_input.axes[0]
                if self.system_type == 'spot':
                    self.joystick_y = self.joystick_input.axes[1]
                    self.joystick_lateral = self.joystick_input.axes[2]
                else:
                    self.joystick_y = self.joystick_input.axes[2]
                    self.joystick_lateral = self.joystick_input.axes[1]


            # Check arming / disarming and mavstate
            self.valid_arm_disarm_data = True
            if self.enable_mavros_timeout:
                if math.fabs(now - self.mavros_arm_state_time) > self.mavros_arm_data_timeout:
                    rospy.logwarn_throttle(5, "Mavros state data is %3.2f old."%(now - self.mavros_arm_state_time))
                    self.messages.addMessage("[WARN] Mavros state data is %3d old."%(int(now - self.mavros_arm_state_time)), 0.1)
                    self.valid_arm_disarm_data = False

            if self.arm_request or self.disarm_request:
                self.requestArm(self.arm_request, self.disarm_request)
                self.arm_request = False
                self.disarm_request = False

            # Make sure odometry is good
            if math.fabs(now - self.last_odom_time) > self.odom_failure_timeout and self.mode is not Modes.INIT_MODE:
                rospy.logwarn_throttle(5, "Odometry is %3.2f old."%(now - self.last_odom_time))
                self.messages.addMessage("[ERROR] Odometry is %3d old, forcing manual mode."%(int(now - self.last_odom_time)), 0.1)
                self.mode = Modes.MANUAL_MODE

            # Process the current mode and process the command
            cmd_type, msg = self.mode_handlers[self.mode][0]()

            if cmd_type == "DIR":
                self.direction_input_pub.publish(msg)
            elif cmd_type == "WPT":
                self.goal_input_pub.publish(msg)
            elif cmd_type == "TWST":
                self.twist_output_pub.publish(msg)
            elif cmd_type == "NOOP":
                pass
            else:
                rospy.logerr_throttle(5, "Unknown command type: %s"%(cmd_type))

            # Publish out any active waypoints
            ## First we process any timeouts on the waypoints from the waypoint function
            if self.mode != Modes.WAYPOINT_MODE:
                self.waypoint_enter_function()
            ## We only publish the exploration waypoint if we are in exploration and it exists
            if self.mode == Modes.EXPLORATION_MODE:
                if self.exploration_waypoint is not None:
                    self.publish_active_waypoints(self.exploration_waypoint.header, [self.exploration_waypoint.pose])

            elif self.waypoints is not None:
                self.publish_active_waypoints(self.waypoints.header, self.waypoints.poses)
            else:
                header = Header()
                header.stamp = rospy.Time.now()
                header.frame_id = "global"
                self.publish_active_waypoints(header, [])

            # Give feedback to the rest of the system
            state_int_msg = UInt8()
            state_string_msg = String()
            arm_state = Bool()
            mav_str = "Arm status unknown"
            if self.mavros_is_armed is not None:
                arm_state.data = self.mavros_is_armed
            elif not self.enable_mavros_timeout:
                arm_state.data = True
            state_string_msg.data = Modes.toString(self.mode)
            state_int_msg.data = self.mode
            self.state_string_pub.publish(state_string_msg)
            self.state_int_pub.publish(state_int_msg)
            self.arm_state_pub.publish(arm_state)
            
            messages_msg = String()
            messages_msg.data = "\n".join(self.messages.getMessages())
            self.messages_pub.publish(messages_msg)

            r.sleep()

    ###########################################################################
    # Callbacks!
    ###########################################################################
    def joyCB(self, msg):
        if len(msg.axes) < 2:
            rospy.logerr_throttle(2, "Joystick Input Does not have enough axes!")
            self.messages.addMessage("[ERR] Joystick Input Does not have enough axes!", 0.1)
            return
        self.joystick_input = msg
        self.joystick_input_time = time.time()

    def stateRequestCB(self, msg):
        if math.fabs(time.time() - self.state_change_time) < self.state_change_timeout:
            return
        
        self.state_change_time = time.time()
        requested_state = msg.data
        if Modes.isValid(requested_state):
            self.transition(requested_state)
            if self.system_type == 'spot':
                rospy.wait_for_service('spot/locomotion_mode')
                if(requested_state == Modes.JOYSTICK_MODE):
                    try:
                        response = self.spot_locomotion_service(3)
                        response = self.spot_stair_service(True)
                        rospy.loginfo("Changed locomtion hint to 3(Trot), Enabled Stair Mode")
                    except Exception as err:
                        print(err)
                if(requested_state == Modes.MANUAL_MODE):
                    try:
                        response = self.spot_locomotion_service(3)
                        response = self.spot_stair_service(False)
                        rospy.loginfo("Changed locomtion hint to 3(Trot), Disabled Stair Mode")
                    except Exception as err:
                        print(err)
        else:
            rospy.logerr("Invalid state requested: %d"%requested_state)
            self.messages.addMessage("[ERR] Invalid state requested: %d"%requested_state)

    def armRequestCB(self, msg):
        if msg.data:
            self.arm_request = True
        else:
            self.disarm_request = True

    def waypointsCB(self, msg):
        self.waypoints_idx = 0
        self.waypoints = msg
        self.waypoint_exit_time = None

    def explorationEnableCB(self, msg):
        self.exploration_enabled = msg.data

    # def lock_statusCB(self, msg):
    #     self.lock_status_pub.publish(msg)

    ###########################################################################
    # System Callbacks
    ###########################################################################
    def explorationWaypointCB(self, msg):
        self.exploration_waypoint = msg

    def explorationCompleteCB(self, msg):
        self.exploration_complete = True

    def hardwareArmCB(self, msg):
        self.mavros_is_armed = msg.data
        self.mavros_arm_state_time = time.time()

    def odometryCB(self, msg):
        if self.odom is None:
            self.first_odom_time = time.time()
        self.last_odom_time = time.time()
        self.odom = msg

    def diskUsageCB(self, msg):
        fl_msg = Float32()
        fl_msg.data = msg.data
        self.disk_float_pub.publish(fl_msg)

    def cpuStatsCB(self, msg):
        fl_msg = Float32()
        fl_msg.data = msg.data
        self.cpu_float_pub.publish(fl_msg)
    
    def isLeaderCB(self, msg):
        self.is_leader = msg.data
    
    def inConvoyCB(self, msg):
        self.in_convoy = msg.data

    def followingOdomCB(self, msg):
        self.following_odom = msg
    
    def speedRatioCB(self, msg):
        self.conv_speed_ratio = msg.data

if __name__ == "__main__":
    rospy.init_node("executive_node")
    node = ExecutiveNode()
    node.run()
