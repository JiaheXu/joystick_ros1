#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Jan 28 14:15:54 2022
@author: kch34
"""
from pymavlink import mavutil
import pymap3d
import time
import math
import rospy
from scipy.spatial.transform import Rotation as R
from mmpug_msgs.msg import MMPUGModes
from geometry_msgs.msg import PointStamped, PoseArray, Pose
from std_msgs.msg import UInt8, Bool, String
from sensor_msgs.msg import Joy
from nav_msgs.msg import Odometry
from mmpug_msgs.msg import MMPUGModes

#please

class PYMAVInterface():
    def __init__(self):
        self.params = {}

        self.home_lat = 40.441443
        self.home_lon = -79.943548
        self.home_alt = 1223
        self.home_hdng = 0

        self.home_x = 0
        self.home_y = 0
        self.home_z = 0
        self.home_yaw = 0

        self.odom_x = 0
        self.odom_y = 0
        self.odom_z = 0
        self.odom_yaw = 0

        # MAV_MODE_INT: (MAV_MODE_STRING, MMPUG_MODE_STRING, MMPUG_MODE_INT)
        # ICD MAPPING
        self.mode_mapping = {
            0:  ("STABILIZE",       "JOYSTICK",     MMPUGModes.JOYSTICK_MODE),
            1:  ("ACRO",            "MANUAL",       MMPUGModes.MANUAL_MODE),
            3:  ("AUTO",            "EXPLORATION",  MMPUGModes.EXPLORATION_MODE),
            4:  ("GUIDED",          "WAYPOINT",     MMPUGModes.WAYPOINT_MODE)
            # 20: ("GUIDED_NO_GPS",   "WAYPOINT",     MMPUGModes.WAYPOINT_MODE)
        }
        # QGC MAPPING
        # self.mode_mapping = {
        #     6:  ("FOLLOW",          "JOYSTICK",     MMPUGModes.JOYSTICK_MODE),
        #     0:  ("MANUAL",          "MANUAL",       MMPUGModes.MANUAL_MODE),
        #     10: ("AUTO",            "EXPLORATION",  MMPUGModes.EXPLORATION_MODE),
        #     15: ("GUIDED",          "WAYPOINT",     MMPUGModes.WAYPOINT_MODE)
        # }

        # Invert mode mapping for sending status back over mavlink
        self.inverse_mode_map = {}
        for mav_int in self.mode_mapping:
            self.inverse_mode_map[self.mode_mapping[mav_int][2]] = mav_int

        # Current feedback from MMPUG System
        self.armed_status = None
        self.current_mode = None
        self.messages = ""
        self.current_authority = None
        self.current_odometry = None

        self.boot_time = time.time()

        # Setup ROS Interfacing
        rospy.init_node("mavlink_command")
        self.authority_name = rospy.get_param("~authority_name", "mavlink")
        self.connection_type = rospy.get_param("~connection_type", "udpin")
        self.connection_ip = rospy.get_param("~connection_ip", "0.0.0.0")
        self.connection_port = rospy.get_param("~connection_port", "14570")


        self.in_connection = mavutil.mavlink_connection("%s:%s:%s"%(self.connection_type, self.connection_ip, self.connection_port), source_system=1, source_component=1)
        self.out_connection = self.in_connection

        # System Feedback
        self.arm_state_sub = rospy.Subscriber("executive/armed", Bool, self.armedCallback)
        self.mode_sub = rospy.Subscriber("executive/mode/int", UInt8, self.modeCallback)
        self.messages_sub = rospy.Subscriber("executive/messages", String, self.messagesCallback)
        self.authority_sub = rospy.Subscriber("command/authority", String, self.authorityCallback)
        self.odometry_sub = rospy.Subscriber("integrated_to_map", Odometry, self.odometryCallback)

        # Control Interface
        self.authority_request_pub = rospy.Publisher("command/request_authority", String, queue_size=1)
        self.joystick_pub = rospy.Publisher("%s/command/joy"%self.authority_name, Joy, queue_size=1)
        self.mode_pub = rospy.Publisher("%s/command/mode"%self.authority_name, UInt8, queue_size=1)
        self.arm_pub = rospy.Publisher("%s/command/arm"%self.authority_name, Bool, queue_size=1)
        self.explore_pub = rospy.Publisher("%s/command/enable_exploration"%self.authority_name, Bool, queue_size=1)
        self.wp_pub = rospy.Publisher("%s/command/waypoints"%self.authority_name, PoseArray, queue_size=1)

    def loop(self):
        last_sent_heartbeat_time = 0.0
        last_recv_heartbeat_time = 0.0

        last_broadcast = 0.0


        connected = False

        while not rospy.is_shutdown():
            now = time.time()
            if connected and math.fabs(now - last_recv_heartbeat_time) >= 2.0:
                rospy.logwarn("Lost connection.")
                connected = False
            if math.fabs(now - last_sent_heartbeat_time) >= 1.0:
                self.sendHeartbeat()
                last_hearbeat_time = now

            if connected and math.fabs(now - last_broadcast) > 0.2:
                self.out_connection.mav.extended_sys_state_send(0,1)
                self.sendSysStatus()
                self.publishHomePosition()
                last_broadcast = now
            if connected:
                self.publishPosition()
            
            msg = self.in_connection.recv_msg()
            if msg is None:
                time.sleep(0.1)
            elif msg.get_type() == 'BAD_DATA':
                rospy.logerr("WARN: Recieved bad data")
            elif msg.get_type() == "HEARTBEAT":
                last_recv_heartbeat_time = now
                if not connected:
                    rospy.logwarn("Connected")
                    connected = True
            else:
                self.processMessage(msg)

    def processMessage(self, mav_msg):
        mav_msg = mav_msg.to_dict()
        msg_type = mav_msg['mavpackettype']
        if msg_type == "PARAM_REQUEST_LIST":
            if len(self.params) == 0:
                return
            # Add parameters?
        elif msg_type == "COMMAND_LONG":
            command = mav_msg["command"]
            self.processCommand(command, mav_msg)
        elif msg_type == "SET_MODE":
            requested_mode = mav_msg['custom_mode']
            print(requested_mode)
            self.processModeRequest(requested_mode)
        elif msg_type == "REQUEST_DATA_STREAM":
            rospy.loginfo_throttle(1., "Ignoring data_stream request [%d]"%mav_msg["req_stream_id"])
        elif msg_type == "MANUAL_CONTROL":
            joystick_msg = Joy()
            joystick_x = mav_msg["x"] / 1000.
            joystick_y = mav_msg["y"] / 1000.
            joystick_lateral = -mav_msg["r"] / 1000.
            if math.fabs(joystick_x) > 0.2:
                self.requestAuthority()
            joystick_msg.axes = [joystick_x, joystick_y, joystick_lateral]
            self.joystick_pub.publish(joystick_msg)
        elif msg_type == "SET_GPS_GLOBAL_ORIGIN":
            pass
        elif msg_type == "PARAM_SET":
            pass
        elif msg_type == "MISSION_ITEM":
            self.processWaypoint(mav_msg["x"], mav_msg["y"], mav_msg["z"])
        else:
            print(mav_msg)

    def processCommand(self, command, mav_msg):
        if command == 520: # MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES
            self.sendAutopilot()
        elif command == 519: # MAV_CMD_REQUEST_PROTOCOL_VERSION
            # Do Nothing! (seems to be what ardupilot sent back?)
            self.out_connection.mav.command_ack_send(
                519, 0, 0, 0, 0, 0
            )
        elif command == 400: # MAV_CMD_COMPONENT_ARM_DISARM
            if self.armed_status is not None:
                if mav_msg["param1"] == 1 and not self.armed_status:
                    rospy.logwarn("Arming system.")
                elif mav_msg["param1"] != 1 and self.armed_status:
                    rospy.logwarn("Diarming system.")
            arm_cmd = Bool()
            arm_cmd.data = mav_msg["param1"] == 1
            self.arm_pub.publish(arm_cmd)
        elif command == 410: # MAV_CMD_GET_HOME_POSITION
            self.publishHomePosition()
        elif command == 511: # MAV_CMD_SET_MESSAGE_INTERVAL
            rospy.loginfo_throttle(1, "Ignoring request for logs [%d] at rate [%3.2f]"%(mav_msg["param1"], 1e6 / mav_msg["param2"]))
        elif command == 179: # MAV_CMD_DO_SET_HOME
            self.home_lat = mav_msg["param5"]
            self.home_lon = mav_msg["param6"]
            self.home_alt = mav_msg["param7"]
            self.home_hdng = -mav_msg["param4"] * math.pi / 180.
            self.home_x = self.odom_x
            self.home_y = self.odom_y
            self.home_z = self.odom_z
            self.home_yaw = self.odom_yaw - self.home_hdng
            rospy.logwarn("Set home to X: %3.2f, Y: %3.2f, HDNG: %3.3f, YAW: %3.2f"%(
                self.home_x, self.home_y, self.home_hdng * 180 / math.pi, self.home_yaw * 180 / math.pi
            ))
            self.publishHomePosition()
        else:
            print(mav_msg)

    def processModeRequest(self, mode):
        if mode not in self.mode_mapping:
            rospy.logerr("Invalid mode requested %d"%mode)
            return
        self.requestAuthority()
        mode_info = self.mode_mapping[mode]
        rospy.loginfo("Requesting %d: %s == %s"%(mode, mode_info[0], mode_info[1]))
        mode_request_msg = UInt8()
        mode_request_msg.data = mode_info[2]
        self.mode_pub.publish(mode_request_msg)

    def processWaypoint(self, lat, lon, alt):
        waypoints = PoseArray()
        waypoints.header.frame_id = "map"
        ltp_x, ltp_y, ltp_z = self.geoToLTP(lat, lon, alt)
        waypoint = Pose()
        waypoint.position.x = ltp_x
        waypoint.position.y = ltp_y
        if math.fabs(ltp_z) < 100:
            waypoint.position.z = ltp_z
        waypoints.poses.append(waypoint)
        self.wp_pub.publish(waypoints)

    def sendAutopilot(self):
        self.out_connection.mav.autopilot_version_send(
            61935,
            67109119,
            0, 0, 0,
            [48, 101, 53, 50, 98, 97, 102, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [48, 57, 57, 55, 48, 48, 51, 0],
            0, 0, 0,
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        )
    
    def sendHeartbeat(self):
        mav_mode = 0
        system_status = mavutil.mavlink.MAV_STATE_UNINIT
        if self.current_mode is None or self.current_mode == MMPUGModes.INIT_MODE:
            mav_mode = self.inverse_mode_map[MMPUGModes.MANUAL_MODE]
            system_status = mavutil.mavlink.MAV_STATE_BOOT
        elif self.current_mode in self.inverse_mode_map:
            mav_mode = self.inverse_mode_map[self.current_mode]
            system_status = mavutil.mavlink.MAV_STATE_ACTIVE
        else:
            # Not actually sure what to do here (unknown current mmpug mode)
            mav_mode = self.inverse_mode_map[MMPUGModes.MANUAL_MODE]
            system_status = mavutil.mavlink.MAV_STATE_ACTIVE

        base_mode = 61 | 1
        if self.armed_status is not None and self.armed_status:
            base_mode |= 128

        self.out_connection.mav.heartbeat_send(
            10, # type
            3, # autopilot (3 is ardupilot, we want to uniquely identify)
            base_mode, # base_mode
            mav_mode, # custom_mode
            system_status, # system_status
            3  # mavlink_version
        )

    def sendSysStatus(self):
        self.out_connection.mav.sys_status_send(
            33554432 | 16384 | 536870912, # onboard control sensors present
            33554432 | 16384 | 536870912, # onboard control sensors enabled
            33554432 | 16384 | 536870912, # onboard control sensors health
            10, # load
            2900, # voltage battery
            300, # current battery
            30, # battery remaining
            0, # drop rate comm
            0, # errors comm
            0, 0, 0, 0 # errors count 1, 2, 3, 4
        )

    def publishPosition(self):
        lat, lon, alt, ltp_yaw = self.ltpToGeo(self.odom_x, self.odom_y, self.odom_z, self.odom_yaw)
        self.out_connection.mav.global_position_int_send(
            int(time.time() - self.boot_time),
            int(lat * 1e7),
            int(lon * 1e7),
            int(alt * 1e3),
            0, 0, 0, 0, int(100 * ltp_yaw * 180/ math.pi))

    def publishHomePosition(self):
        r = R.from_euler("z", -self.home_yaw)
        self.out_connection.mav.home_position_send(
            int(self.home_lat * 1e7),
            int(self.home_lon * 1e7),
            int(self.home_alt * 1e3),
            0, 0, 0,
            r.as_quat(),
            0, 0, 0,
            int(time.time() * 1e6)
        )

    def requestAuthority(self):
        if self.current_authority != self.authority_name:
            rospy.logwarn_throttle(1, "Requesting authority!")
        auth_req_msg = String()
        auth_req_msg.data = self.authority_name
        self.authority_request_pub.publish(auth_req_msg)

    def armedCallback(self, msg):
        self.armed_status = msg.data

    def modeCallback(self, msg):
        self.current_mode = msg.data

    def messagesCallback(self, msg):
        self.messages = msg.data
        
    def authorityCallback(self, msg):
        self.current_authority = msg.data

    def odometryCallback(self, msg):
        self.odom_x = msg.pose.pose.position.x
        self.odom_y = msg.pose.pose.position.y
        self.odom_z = msg.pose.pose.position.z
        r = R.from_quat([
            msg.pose.pose.orientation.x,
            msg.pose.pose.orientation.y,
            msg.pose.pose.orientation.z,
            msg.pose.pose.orientation.w
        ])
        self.odom_yaw = r.as_euler("zxy")[0]

    def ltpToGeo(self, x, y, z, yaw):
        ltp_ix = x - self.home_x
        ltp_iy = y - self.home_y
        ltp_z = z - self.home_z
        ltp_x = ltp_ix * math.cos(-self.home_yaw) - ltp_iy * math.sin(-self.home_yaw)
        ltp_y = ltp_ix * math.sin(-self.home_yaw) + ltp_iy * math.cos(-self.home_yaw)
        ltp_yaw = self.home_yaw - self.odom_yaw
        while ltp_yaw >= 2*math.pi:
            ltp_yaw -= 2*math.pi
        while ltp_yaw < 0:
            ltp_yaw += 2*math.pi

        lat, lon, alt = pymap3d.enu2geodetic(-ltp_y, ltp_x, ltp_z, self.home_lat, self.home_lon, self.home_alt)
        return lat, lon, alt, ltp_yaw

    def geoToLTP(self, lat, lon, alt):
        ltp_iny, ltp_ix, ltp_iz = pymap3d.geodetic2enu(lat, lon, alt, self.home_lat, self.home_lon, self.home_alt)
        ltp_z = self.home_z + ltp_iz
        ltp_x = self.home_x + ltp_ix * math.cos(self.home_yaw) - (-ltp_iny) * math.sin(self.home_yaw)
        ltp_y = self.home_y + ltp_ix * math.sin(self.home_yaw) + (-ltp_iny) * math.cos(self.home_yaw)
        return ltp_x, ltp_y, ltp_z



    
if __name__ == '__main__':
    mavros_arbitrator = PYMAVInterface()
    mavros_arbitrator.loop()
 
